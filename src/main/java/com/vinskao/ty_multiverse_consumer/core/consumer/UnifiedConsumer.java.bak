package com.vinskao.ty_multiverse_consumer.core.consumer;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.vinskao.ty_multiverse_consumer.core.dto.AsyncMessageDTO;
import com.vinskao.ty_multiverse_consumer.core.service.AsyncResultService;
import com.vinskao.ty_multiverse_consumer.module.people.service.PeopleService;
import com.vinskao.ty_multiverse_consumer.module.people.service.WeaponDamageService;
import com.vinskao.ty_multiverse_consumer.module.weapon.service.WeaponService;
import com.vinskao.ty_multiverse_consumer.module.people.domain.vo.People;
import com.vinskao.ty_multiverse_consumer.module.weapon.domain.vo.Weapon;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

/**
 * 統一 Consumer
 * 處理所有隊列的消息，使用統一的 AsyncMessageDTO 格式
 * 使用新的 AsyncResultService 發送結果到 async-result 隊列
 */
@Component
@ConditionalOnProperty(name = "spring.rabbitmq.enabled", havingValue = "true")
public class UnifiedConsumer {
    
    private static final Logger logger = LoggerFactory.getLogger(UnifiedConsumer.class);
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private AsyncResultService asyncResultService;
    
    @Autowired
    private PeopleService peopleService;
    
    @Autowired
    private WeaponService weaponService;
    
    @Autowired
    private WeaponDamageService weaponDamageService;
    
    // ==================== People 相關隊列 ====================
    
    /**
     * 處理傷害計算請求（舊隊列，已棄用）
     * 此方法已棄用，請使用 people-damage-calculation 隊列
     */
    // @RabbitListener(queues = "damage-calculation", concurrency = "2")
    public void handleDamageCalculation(String messageJson) {
        try {
            logger.info("收到傷害計算請求（舊隊列，已棄用）: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String characterName = (String) message.getPayload();
            int damage = weaponDamageService.calculateDamageWithWeapon(characterName);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                damage
            );
            
        } catch (Exception e) {
            logger.error("處理傷害計算請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理獲取所有角色請求（已移除，避免與 PeopleConsumer 競爭）
     * 改由 PeopleConsumer.handleGetAllPeople 處理
     */
    // @RabbitListener(queues = "people-get-all", concurrency = "2")
    public void handlePeopleGetAll(String messageJson) {
        try {
            logger.info("收到獲取所有角色請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            List<People> peopleList = peopleService.getAllPeopleOptimized();
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                peopleList
            );
            
        } catch (Exception e) {
            logger.error("處理獲取所有角色請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理插入角色請求
     */
    @RabbitListener(queues = "people-insert", concurrency = "2")
    public void handlePeopleInsert(String messageJson) {
        try {
            logger.info("收到插入角色請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            People people = objectMapper.convertValue(message.getPayload(), People.class);
            People savedPeople = peopleService.insertPerson(people);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                savedPeople
            );
            
        } catch (Exception e) {
            logger.error("處理插入角色請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理更新角色請求
     */
    @RabbitListener(queues = "people-update", concurrency = "2")
    public void handlePeopleUpdate(String messageJson) {
        try {
            logger.info("收到更新角色請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            People people = objectMapper.convertValue(message.getPayload(), People.class);
            People updatedPeople = peopleService.updatePerson(people);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                updatedPeople
            );
            
        } catch (Exception e) {
            logger.error("處理更新角色請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理插入多個角色請求
     */
    @RabbitListener(queues = "people-insert-multiple", concurrency = "2")
    public void handlePeopleInsertMultiple(String messageJson) {
        try {
            logger.info("收到插入多個角色請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            @SuppressWarnings("unchecked")
            List<People> peopleList = objectMapper.convertValue(message.getPayload(), 
                objectMapper.getTypeFactory().constructCollectionType(List.class, People.class));
            
            List<People> savedPeople = peopleService.saveAllPeople(peopleList);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                savedPeople
            );
            
        } catch (Exception e) {
            logger.error("處理插入多個角色請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理根據名稱獲取角色請求
     */
    @RabbitListener(queues = "people-get-by-name", concurrency = "2")
    public void handlePeopleGetByName(String messageJson) {
        try {
            logger.info("收到根據名稱獲取角色請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String name = (String) message.getPayload();
            Optional<People> people = peopleService.getPeopleByName(name);
            
            if (people.isPresent()) {
                asyncResultService.sendCompletedResult(
                    message.getRequestId(), 
                    people.get()
                );
            } else {
                asyncResultService.sendFailedResult(
                    message.getRequestId(), 
                    "找不到名稱為 " + name + " 的角色"
                );
            }
            
        } catch (Exception e) {
            logger.error("處理根據名稱獲取角色請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理刪除角色請求
     */
    @RabbitListener(queues = "people-delete", concurrency = "2")
    public void handlePeopleDelete(String messageJson) {
        try {
            logger.info("收到刪除角色請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String name = (String) message.getPayload();
            // TODO: 實現單個刪除邏輯
            logger.warn("單個刪除功能尚未實現: name={}", name);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                null
            );
            
        } catch (Exception e) {
            logger.error("處理刪除角色請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理刪除所有角色請求
     */
    @RabbitListener(queues = "people-delete-all", concurrency = "2")
    public void handlePeopleDeleteAll(String messageJson) {
        try {
            logger.info("收到刪除所有角色請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            peopleService.deleteAllPeople();
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                null
            );
            
        } catch (Exception e) {
            logger.error("處理刪除所有角色請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理傷害計算請求（people-damage-calculation 隊列）
     */
    @RabbitListener(queues = "people-damage-calculation", concurrency = "2")
    public void handlePeopleDamageCalculation(String messageJson) {
        try {
            logger.info("收到角色傷害計算請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String characterName = (String) message.getPayload();
            int damage = weaponDamageService.calculateDamageWithWeapon(characterName);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                damage
            );
            
        } catch (Exception e) {
            logger.error("處理角色傷害計算請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    // ==================== Weapon 相關隊列 ====================
    
    /**
     * 處理獲取所有武器請求
     */
    @RabbitListener(queues = "weapon-get-all", concurrency = "2")
    public void handleWeaponGetAll(String messageJson) {
        try {
            logger.info("收到獲取所有武器請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            List<Weapon> weapons = weaponService.getAllWeapons();
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                weapons
            );
            
        } catch (Exception e) {
            logger.error("處理獲取所有武器請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理根據名稱獲取武器請求
     */
    @RabbitListener(queues = "weapon-get-by-name", concurrency = "2")
    public void handleWeaponGetByName(String messageJson) {
        try {
            logger.info("收到根據名稱獲取武器請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String name = (String) message.getPayload();
            Optional<Weapon> weapon = weaponService.getWeaponById(name);
            
            if (weapon.isPresent()) {
                asyncResultService.sendCompletedResult(
                    message.getRequestId(), 
                    weapon.get()
                );
            } else {
                asyncResultService.sendFailedResult(
                    message.getRequestId(), 
                    "找不到名稱為 " + name + " 的武器"
                );
            }
            
        } catch (Exception e) {
            logger.error("處理根據名稱獲取武器請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理根據擁有者獲取武器請求
     */
    @RabbitListener(queues = "weapon-get-by-owner", concurrency = "2")
    public void handleWeaponGetByOwner(String messageJson) {
        try {
            logger.info("收到根據擁有者獲取武器請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String owner = (String) message.getPayload();
            List<Weapon> weapons = weaponService.getWeaponsByOwner(owner);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                weapons
            );
            
        } catch (Exception e) {
            logger.error("處理根據擁有者獲取武器請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理保存武器請求
     */
    @RabbitListener(queues = "weapon-save", concurrency = "2")
    public void handleWeaponSave(String messageJson) {
        try {
            logger.info("收到保存武器請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            Weapon weapon = objectMapper.convertValue(message.getPayload(), Weapon.class);
            Weapon savedWeapon = weaponService.saveWeapon(weapon);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                savedWeapon
            );
            
        } catch (Exception e) {
            logger.error("處理保存武器請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理刪除武器請求
     */
    @RabbitListener(queues = "weapon-delete", concurrency = "2")
    public void handleWeaponDelete(String messageJson) {
        try {
            logger.info("收到刪除武器請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String name = (String) message.getPayload();
            weaponService.deleteWeapon(name);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                null
            );
            
        } catch (Exception e) {
            logger.error("處理刪除武器請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理刪除所有武器請求
     */
    @RabbitListener(queues = "weapon-delete-all", concurrency = "2")
    public void handleWeaponDeleteAll(String messageJson) {
        try {
            logger.info("收到刪除所有武器請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            weaponService.deleteAllWeapons();
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                null
            );
            
        } catch (Exception e) {
            logger.error("處理刪除所有武器請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理檢查武器存在請求
     */
    @RabbitListener(queues = "weapon-exists", concurrency = "2")
    public void handleWeaponExists(String messageJson) {
        try {
            logger.info("收到檢查武器存在請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            String name = (String) message.getPayload();
            boolean exists = weaponService.weaponExists(name);
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                exists
            );
            
        } catch (Exception e) {
            logger.error("處理檢查武器存在請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理更新武器屬性請求
     */
    @RabbitListener(queues = "weapon-update-attributes", concurrency = "2")
    public void handleWeaponUpdateAttributes(String messageJson) {
        try {
            logger.info("收到更新武器屬性請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            // TODO: 實現更新武器屬性邏輯
            logger.warn("更新武器屬性功能尚未實現");
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                null
            );
            
        } catch (Exception e) {
            logger.error("處理更新武器屬性請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    /**
     * 處理更新武器基礎傷害請求
     */
    @RabbitListener(queues = "weapon-update-base-damage", concurrency = "2")
    public void handleWeaponUpdateBaseDamage(String messageJson) {
        try {
            logger.info("收到更新武器基礎傷害請求: {}", messageJson);
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            // TODO: 實現更新武器基礎傷害邏輯
            logger.warn("更新武器基礎傷害功能尚未實現");
            
            asyncResultService.sendCompletedResult(
                message.getRequestId(), 
                null
            );
            
        } catch (Exception e) {
            logger.error("處理更新武器基礎傷害請求失敗: {}", e.getMessage(), e);
            handleError(messageJson, e);
        }
    }
    
    // ==================== 錯誤處理 ====================
    
    /**
     * 統一錯誤處理方法
     */
    private void handleError(String messageJson, Exception e) {
        try {
            AsyncMessageDTO message = objectMapper.readValue(messageJson, AsyncMessageDTO.class);
            
            // 發送錯誤結果
            asyncResultService.sendFailedResult(
                message.getRequestId(),
                "處理請求失敗: " + e.getMessage()
            );
            
        } catch (Exception ex) {
            logger.error("處理錯誤回應失敗: {}", ex.getMessage(), ex);
        }
    }
}
